- id: "code-exploration-and-understanding"
  title: "Codebase Exploration and Understanding"
  questions:
    - "How do I add a new $X?"
    - "What functions or modules relate to $TOPIC?"
    - "What is the purpose of $MODULE or $FILE?"
    - "How does $FEATURE work in this project?"
    - "What does $VARIABLE or $STRUCT represent?"
  prompt: |
    1. Use the `search_tool` to perform a semantic search for `$X` or `$TOPIC` across the project files.
    2. If the user specifies a module or file, use the `file_info_tool` to summarize its purpose.
    3. If no specific file is mentioned, list relevant files using `list_files_tool` and identify candidates based on their names or summaries.
    4. Use the `file_contents_tool` to fetch key files or relevant excerpts.
    5. Analyze the flow and context of `$VARIABLE` or `$STRUCT` using references from search results.
    6. If git tools are available, consider using `git_log_tool` to explore the history of relevant files or functions.
    7. Synthesize a concise and actionable response summarizing findings and next steps.

- id: "debugging-and-troubleshooting"
  title: "Debugging and Troubleshooting"
  questions:
    - "What's the root cause of this error? $STACKTRACE"
    - "What changes recently introduced $BUG or $ERROR?"
    - "What file defines $FUNCTION or $CONSTANT?"
  prompt: |
    1. Analyze the Error Context:
       - If `$STACKTRACE` or `$ERROR` is provided, use `search_tool` to locate the associated line numbers, modules, or functions in the codebase. Focus on identifying the source of the issue.
       - Take note of any assumptions that can safely be made based on the query or programming language (e.g. immutability, type safety).
    2. Investigate Specific Identifiers:
       - If a specific function, method, or constant is mentioned:
         - Use `file_info_tool` to retrieve its definition and inspect its surrounding context (e.g., imports, dependencies, or usage patterns).
         - Use `search_tool` to locate references to the identifier throughout the project.
    3. Trace Code Relationships:
       - Use `spelunker_tool` to analyze upstream callers or downstream callees of `$FUNCTION`. Leverage the prebuilt call map to trace function interactions, dependencies, and affected pathways.
    4. Analyze Code History:
       - Use `git_pickaxe_tool` to search the commit history for changes introducing `$BUG` or `$ERROR`. Prioritize:
         - Lines or functions relevant to the stack trace or function mentioned.
         - Commit messages and diffs for context.
       - Supplement with other git tools (e.g., `git_log_tool`, `git_show_tool`) for broader or specific commit details.
       - **Important**: Only use Git tools if they are included in the available tools list.
    5. Correlate Findings Across Tools:
       - Cross-reference results from `search_tool`, `file_info_tool`, and `spelunker_tool` to establish a clear picture of:
         - Which modules or functions are likely involved.
         - How changes in the codebase might correlate with the observed bug.
    6. Summarize and Recommend Actions:
       - Provide a detailed explanation of the root cause, including:
         - Specific references to files, functions, or commits.
         - Hypotheses based on tool outputs (e.g., a faulty function call, a breaking change).
       - If no root cause could be identified:
         - Clearly note in bold that you were unable to find the root cause.
         - Recommend further steps for debugging or troubleshooting
           - Write a test case to reproduce the error
           - Cite locations in the code to insert printf-debugging or logging

- id: "code-flow-and-relationships"
  title: "Code Flow and Relationships"
  questions:
    - "What is the logical flow from function $X to function $Y?"
    - "What modules or functions call $X?"
    - "Where is $Y used in the project?"
  prompt: |
    1. Use the `spelunker_tool` to map the logical flow and identify callers or callees of `$X` and `$Y`.
    2. Use `search_tool` to locate semantic matches for `$X` and `$Y` in project files to identify references.
    3. If detailed analysis is needed, fetch the full contents of relevant files using `file_contents_tool`.
    4. Supplement insights by reviewing related file summaries via `file_info_tool`.
    5. Use git tools (e.g., `git_log_tool`) ONLY if explicitly available, to trace historical changes or commits associated with `$X` or `$Y`.
    6. Compile a step-by-step logical flow or dependency graph between `$X` and `$Y`.

- id: "test-and-build-information"
  title: "Test and Build Information"
  questions:
    - "How do I run the tests?"
    - "What tests exist for $FEATURE?"
    - "Where is the CI configuration defined, and how does it work?"
    - "What dependencies are required to build this project?"
  prompt: |
    1. Use `search_tool` to locate references to "tests," "CI," or "dependencies" in files and directories.
    2. If a specific `$FEATURE` is mentioned, search for test files or test-related comments.
    3. Use `list_files_tool` to identify `README`, configuration files (e.g., `docker-compose.yml`, `.env`, `Makefile`), or CI scripts.
    4. Use `file_contents_tool` to examine key files such as `README.md` or `build` scripts for instructions.
    5. If git tools are available, inspect commit history (`git_log_tool`) to identify recent CI or test changes.
    6. Summarize testing or build instructions, linking dependencies or configurations to their usage.

- id: "version-history-and-changes"
  title: "Version History and Changes"
  questions:
    - "When was $FUNCTION or $MODULE added or modified?"
    - "What does the commit history for $FILE look like?"
    - "Who wrote $CODE_SNIPPET, and why was it added?"
  prompt: |
    1. If git tools are available, use `git_log_tool` to identify when `$FUNCTION` or `$MODULE` was added or modified. DO NOT use git tools if not listed in the available tools.
    2. Use `git_pickaxe_tool` to search commit diffs for `$CODE_SNIPPET` or `$FUNCTION`.
    3. Use `file_info_tool` to cross-reference definitions or modifications in relevant files.
    4. If the project is not a git repository, rely on `search_tool` and `list_files_tool` to approximate relevant files.
    5. Summarize findings with commit details, authors, and reasons (if documented).

- id: "semantic-search-and-high-level-summaries"
  title: "Semantic Search and High-Level Summaries"
  questions:
    - "Where in the project is $TOPIC discussed?"
    - "Summarize the implementation of $FEATURE."
    - "What patterns or libraries are used in $FEATURE?"
  prompt: |
    1. Use `search_tool` to perform a semantic search for `$TOPIC` or `$FEATURE` in the project.
    2. Summarize findings using AI-generated summaries of matched files, fetched via `file_info_tool`.
    3. Identify patterns, libraries, or dependencies from related files or their comments.
    4. If necessary, fetch full files using `file_contents_tool` to extract implementation details.
    5. If git tools are available, use them for historical context (e.g., `git_log_tool`).
    6. Compile a clear, high-level summary for the user, referencing specific files or patterns.

- id: "operational-and-setup-tasks"
  title: "Operational and Setup Tasks"
  questions:
    - "How do I set up this project locally?"
    - "What environment variables are required?"
    - "How is $SERVICE configured to run in this project?"
  prompt: |
    1. Use `list_files_tool` to locate setup-related files (`README.md`, `.env`, `docker-compose.yml`, etc.).
    2. Search for mentions of "setup," "installation," or `$SERVICE` using `search_tool`.
    3. Use `file_info_tool` to summarize key configuration files and settings.
    4. If available, examine file contents using `file_contents_tool` for detailed instructions.
    5. If git tools are available, examine setup-related commits for historical context.
    6. Provide a step-by-step setup guide based on extracted information.

- id: "documentation-and-metadata"
  title: "Documentation and Metadata"
  questions:
    - "What does the documentation say about $FEATURE or $MODULE?"
    - "What README or guide exists for $TOPIC?"
    - "What file contains instructions for $SETUP?"
  prompt: |
    1. Use `list_files_tool` to identify documentation files such as `README.md`, `CONTRIBUTING.md`, or guides.
    2. Perform a semantic search using `search_tool` for mentions of `$FEATURE`, `$MODULE`, or `$SETUP`.
    3. Use `file_info_tool` to summarize documentation sections or metadata relevant to the query.
    4. If detailed content is needed, use `file_contents_tool` to extract specific sections or guides.
    5. Synthesize an answer by compiling key documentation references.

- id: "code-review-and-analysis"
  title: "Code Review and Analysis"
  questions:
    - "What changes were introduced in $TOPIC_BRANCH?"
    - "Are there any potential issues with the recent commits?"
    - "How do the changes in $TOPIC_BRANCH impact the rest of the project?"
    - "What files or functions were most affected by these changes?"
    - "Please explain changes to business logic in $TOPIC_BRANCH."
    - "Please conduct a code review of $TOPIC_BRANCH."
  prompt: |
    1. Use `git_diff_branch_tool` to retrieve a diff between `$TOPIC_BRANCH` and `$BASE_BRANCH` (default to `origin/main` unless specified by the user).
    2. Summarize the changes by extracting key additions, deletions, and modifications. Highlight files and functions with significant changes.
    3. Use `git_show_tool`, `file_contents_tool`, `file_info_tool`, and `search_tool` to cross-reference affected files or functions for their context and purpose within the project.
    4. If relevant, trace dependencies or relationships using `spelunker_tool` to understand downstream or upstream impacts.
    5. Identify potential issues, but generally restrict your analysis to the code being changed
      - Do focus on:
        - Logical errors or inconsistencies
        - Poor separation of concerns
        - Conflicts with existing functionality
        - Missing test cases for new features or changes
        - Unnecessary complexity introduced in the code
        - Spelling errors, typos, or inconsistent naming conventions
        - Missing documentation or comments
      - Do not focus on:
        - Separation of concerns in the codebase as a whole
        - Missing test cases in the code base as a whole
    6. Synthesize a review summary with:
      - Key changes.
      - Observed strengths and areas for improvement.
      - Suggestions for additional testing, refactoring, or documentation.
    7. NOTE that your other git tools may refer to local or remote versions of files depending on their arguments, so be cautious when using them for code review purposes.
